% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/infer_source_bayesian.R
\name{infer_source_bayesian}
\alias{infer_source_bayesian}
\title{Inference Source via Gaussian source estimation with prior information}
\usage{
infer_source_bayesian(
  cases.node.day,
  thres.vec,
  obs.vec,
  mu.mat,
  lambda.list,
  poss.candidate.vec,
  prior,
  use.prior = TRUE
)
}
\arguments{
\item{cases.node.day}{matrix, number of nodes x time points; entries represent number of cases}

\item{thres.vec}{vector, length represents number of cities/nodes, representing
thresholds for cities/nodes that they are infected}

\item{obs.vec}{list of cities ids used as observers}

\item{mu.mat}{matrix- number of cities/nodes x number of observers, each row represents- 
if this node is the source, the mean of arrival time vector}

\item{lambda.list}{a length-number of cities/nodes list, each element is a number of observers x number of observers matrix-
if a node is the source, the covariance matrix for arrival time vector}

\item{poss.candidate.vec}{a boolean vector indicating if a node has the potential to be the source}

\item{prior}{vector, length - number of cities/nodes, prior for cities}

\item{use.prior}{boolean, TRUE or FALSE, if use prior, default TRUE}
}
\value{
a dataframe with columns 'nodes' and 'probab', indicating nodes indices and their posteriors
}
\description{
\code{infer_source_bayesian} Compute posterior probabilities for all nodes and rank them
}
\examples{
library(NetOrigin)
# load training data
load('.../train_data.rda')
obs.vec <- (1:9)
candidate.thres <- 0.3
mu.lambda.list <- compute_mu_lambda(train.data, obs.vec, candidate.thres)
# load matrix representing number of cases per node per day, size-number of nodes x number of day
load('.../cases_node_day.rda')
# number of nodes
nnodes <- dim(cases.node.day)[1] 
# fixed threshold for all nodes - 10 infected people
thres.vec <- rep(10, nnodes)
# flat/non-informative prior
prior <- rep(1, nnodes) 
result2.df <- infer.source.bayesian(cases.node.day, 
                                    thres.vec,
                                    obs.vec,
                                    mu.lambda.list$mu.mat, mu.lambda.list$lambda.list, 
                                    mu.lambda.list$poss.candidate.vec,
                                    prior, TRUE)
}

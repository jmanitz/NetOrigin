POP
S
sumS
I
sumI
R
sumR
cumcase
B
beat
beta
B
m
(1-m)*beta*B/(1+B)
sum((1-m)*beta*B/(1+B))
beta*B/(B+1))*m
(beta*B/(B+1))*m
## initial values
FORCE=((1-m)*beta*B/(1+B)+fluxes%*%(beta*B/(B+1))*m)  #force of infection for each node
FORCE
INFECTION=FORCE*S;                                    #infection rate for each node
INFECTION
sumINF=sum(INFECTION) # sum of infection rates
sumINF
t=time_sim[1] # time
t_prev=t # previous time at which B was updated
index_t=1
t
t_prev
index_t
I_node_t_SS=matrix(0, nnodes, length(time_sim)) # infected for ech node and time point
cumcases_node_t_SS=matrix(0, nnodes, length(time_sim)) # cumulative cases for ech node and time point
I_node_t_SS[, index_t]=I
cumcases_node_t_SS[, index_t]=cumcase # initial value
event_rate=c(sumINF*(1-sigma), sumINF*(sigma), sumI*gamma, sumR*rho,
POP*mu, POP*mu, sumI*alpha)  #total rate for the seven types of events
event_rate
runif(0, 1)
runif(1, 0, 1)
runif(1, 0, 1)
runif(1, 0, 1)
runif(1, 0, 1)
runif(1, 0, 1)
runif(1, 0, 1)
deltat=-log(runif(1, 0, 1))/sum(event_rate);  #timestep to the next event
deltat
deltat=-log(runif(1, 0, 1))/sum(event_rate);  #timestep to the next event
deltat=-log(runif(1, 0, 1))/sum(event_rate);  #timestep to the next event
deltat
event_rate
sample(1:7, size=1, prob = event_rate)
sample(1:7, size=1, prob = event_rate)
sample(1:7, size=1, prob = event_rate)
sample(1:7, size=1, prob = event_rate)
event=sample(1:7, size=1, prob = event_rate)
event
INFECTION
node=sample(1:length(INFECTION), size = 1, prob = INFECTION)
node
S
node=sample(1:length(INFECTION), size = 1, prob = INFECTION)
# update variables
S[node]=S[node]-1
R[node]=R[node]+1
sumS=sumS-1
sumR=sumR+1
INFECTION[node]=INFECTION[node]-FORCE[node]
sumINF=sumINF-FORCE[node]
node
sumINF
node=sample(1:length(INFECTION), size = 1, prob = INFECTION)
# update variables
S[node]=S[node]-1
I[node]=I[node]+1
cumcase[node] = cumcase[node]+1
sumS=sumS-1
sumI=sumI+1
INFECTION[node]=INFECTION[node]-FORCE[node]
sumINF=sumINF-FORCE[node]
node=sample(1:length(INFECTION), size = 1, prob = I)
node=sample(1:length(INFECTION), size = 1, prob = I)
I[node]=I[node]-1
R[node]=R[node]+1
sumI=sumI-1
sumR=sumR+1
node=sample(1:length(INFECTION), size = 1, prob = POP_node_SS)
S[node]=S[node]+1
POP_node_SS[node]=POP_node_SS[node]+1
sumS=sumS+1
POP=POP+1
INFECTION[node]=INFECTION[node]+FORCE[node]
sumINF=sumINF+FORCE[node]
# source function files
dir.rfiles <- "/Users/lijun/Documents/source_detect_2020/storage/"
file.list <- c('compute_mu_lambda_raw.R', 'infer_source_bayesian_raw.R')
for (i in 1:length(file.list)){
source(paste0(dir.rfiles, file.list[i]))
}
# required libraries
library(mvtnorm)
library(corpcor)
## (1) prepare inputs for 'compute.mu.lambda'
load(paste0(dir.rfiles, "timemin_datamat_list_train_threspercent_851.rda"))
load(paste0(dir.rfiles, "obs9deg_before400_042220_01_original.rda"))
train.data <- timemin.datamat.list.train.threspercent.851 # 851 elements, each 300 * 851
obs.vec <- obs9.puredegree
candidate.thres <- 0.3
result1 <- compute.mu.lambda(train.data, obs.vec, candidate.thres)
# > names(result1)
# [1] "mu.mat"             "lambda.list"        "poss.candidate.vec"
## (2) prepare inputs for 'infer.source.bayesian'
library(R.matlab)
rawnet <- readMat(paste0(dir.rfiles, "KZN_dataset.mat"))
R0 <- readMat(paste0(dir.rfiles, "R0.mat"))$R0
cases.node.day <- rawnet$cases.node.day # 851 1312
thres.vec <- round(rawnet$POP.node) * 0.001
obs.vec <- obs9.puredegree
mu.mat <- result1$mu.mat
lambda.list <- result1$lambda.list
poss.candidate.vec <- result1$poss.candidate.vec
prior <- R0
result2.df <- infer.source.bayesian(cases.node.day,
thres.vec,
obs.vec,
mu.mat, lambda.list,
poss.candidate.vec,
prior, TRUE)
# "result2.df"
# cols: "probab", "nodes", ranked decreased
## (3) prepare trained data as input, simulator
POP_node = round(rawnet$POP.node) # use integer number
nnodes=length(POP_node) # number of nodes
mu=1/(65*365)      #population natality and mortality rate (day^-1)
gamma=0.2          #rate at which people recover from cholera (day^-1)
alpha=0            #cholera induced mortality rate (day^-1)
mu_B=0.2           #death rate of V.cholerae in the aquatic environment (day^-1)
rho=0              #immunity loss rate (day^-1)
beta_max=1         #maximum contact contact rate (day^-1)
sigma=0.05         #symptomatic ratio: fraction of infected people that develop symptoms and are infective. The remaining fraction enters directly the recovered compartment
R0_max=20          #maximum reproduction number
D=50
m=0.3
no_water_access = rawnet$no.water.access
no_toilet_access = rawnet$no.toilet.access
distances = rawnet$distances # 851-851
## initial condition
node_in=c(428, 432) #initially infected node
in_prevalence=0.001 #initial prevalence of symptomatic infected
## time for simulation [day]
time_sim=seq(0, 100, by=0.1)
##
theta_max=R0_max*(mu_B)*(gamma+alpha+mu)/(beta_max*sigma) #maximum contamination rate
beta=beta_max*no_water_access
theta=theta_max*no_toilet_access
R0=theta*beta*sigma/(mu_B*(gamma+alpha+mu))
pop_matrix=matrix(0, 851, 851)
diag(pop_matrix)=POP_node
fluxes=exp(-distances/D)%*%pop_matrix
diag(fluxes)=0
mat_rowsum_flux = matrix(rep(rowSums(fluxes), 851), 851, 851)
fluxes=fluxes/mat_rowsum_flux
rowSums(fluxes)
load("~/Desktop/plos_one_data.rda")
rowSums(time.of.arrival)
max(time.of.arrival)
dir.rfiles <- "/Users/lijun/Documents/source_detect_2020/storage/"
load(paste0(dir.rfiles, "plos_one_data.rda"))
load(paste0(dir.rfiles, "plos_one_data.rda"))
dir.rfiles <- "/Users/lijun/Documents/source_detect_2020/storage/"
load(paste0(dir.rfiles, "plos_one_data.rda"))
newcases.per.day <- time.of.arrival
rm(list=c("time.of.arrival"))
save.image(paste0(dir.rfiles, "plos_one_data.rda"))
load(paste0(dir.rfiles, "plos_one_data.rda"))
dir.rfiles <- "/Users/lijun/Documents/source_detect_2020/storage/"
load(paste0(dir.rfiles, "plos_one_data.rda"))
lati.long.851
27814.49 - 26410.13
1404.36/4
install.packages("rlang")
# visualize the observers
library(mvtnorm)
library(R.matlab)
library(tidygraph)
library(ggraph)
dir.rfiles <- "/Users/lijun/Documents/source_detect_2020/storage/" # path for .mat data
rawnet <- readMat(paste0(dir.rfiles, 'KZN_dataset.mat'))
R0 <- readMat(paste0(dir.rfiles, "R0.mat"))$R0
R0 <- R0/max(R0) * 5.6
humanmob.mass <- readMat(paste0(dir.rfiles, 'human_mob_in_851.mat'))$fluxes
library(igraph)
max(humanmob.mass) # 0.2487348
quantile(as.vector(humanmob.mass))
# 0%          25%          50%          75%         100%
# 0.0000000000 0.0000242024 0.0001417434 0.0007166013 0.2487347872
df.humanmob <- data.frame(weight=as.vector(humanmob.mass))
library(ggplot2)
ggplot(df.humanmob, aes(x=weight)) + geom_histogram(binwidth = 0.0001) + scale_y_log10()
ggsave(paste0(dir.rfiles, "human_mobility_wts.pdf"),
width = 6, height = 4)
# use 0.01 as threshold: 16047 links
sum(df.humanmob$weight > 0.01)
A.cut05 <- 1 * (humanmob.mass > 0.01)
sum(sum(A.cut05)) / (851^2) # about 2.2%
num.edges <- sum(sum(A.cut05))
G.cut05 <- graph_from_adjacency_matrix(A.cut05, mode = "directed")
ClustCoefDir <- function(graph) {
A <- as.matrix(get.adjacency(graph))
S <- A + t(A)
deg <- degree(graph, mode = c("total"))
num <- diag(S %*% S %*% S)
denom <- diag(A %*% A)
denom <- 2 * (deg * (deg - 1) - 2 * denom)
cl <- mean(num / denom)
return(cl)
}
humanmob.clustcoef <- ClustCoefDir(G.cut05)
humanmob.clustcoef # 0.5675805
average.path.length(G.cut05) # 4.027839
ntrials <- 10
nv <- vcount(G.cut05)
ne <- ecount(G.cut05)
cl.rg <- numeric(ntrials)
apl.rg <- numeric(ntrials)
for (i in (1:ntrials)) {
g.rg <- erdos.renyi.game(nv, ne, type="gnm", directed = TRUE)
cl.rg[i] <- ClustCoefDir(g.rg)
apl.rg[i] <- average.path.length(g.rg)
print(i)
print("\n")
}
summary(cl.rg)
# Min. 1st Qu.  Median    Mean 3rd Qu.    Max.
# 0.02144 0.02201 0.02218 0.02219 0.02235 0.02298
summary(apl.rg)
# Min. 1st Qu.  Median    Mean 3rd Qu.    Max.
# 2.622   2.624   2.624   2.624   2.625   2.626
library("ggplot2")
theme_set(theme_bw())
library("sf")
library("rnaturalearth")
library("rnaturalearthdata")
world <- ne_countries(scale = "medium", returnclass = "sf")
# visualize the observers
library(mvtnorm)
library(R.matlab)
library(tidygraph)
library(ggraph)
dir.rfiles <- "/Users/lijun/Documents/source_detect_2020/storage/" # path for .mat data
rawnet <- readMat(paste0(dir.rfiles, 'KZN_dataset.mat'))
R0 <- readMat(paste0(dir.rfiles, "R0.mat"))$R0
R0 <- R0/max(R0) * 5.6
humanmob.mass <- readMat(paste0(dir.rfiles, 'human_mob_in_851.mat'))$fluxes
flow.goesin <- colSums(humanmob.mass)
sorted.flow.goesin <- sort(flow.goesin, decreasing = TRUE)
which(flow.goesin == sorted.flow.goesin[1]) # 184
which(flow.goesin == sorted.flow.goesin[2]) # 167
which(flow.goesin == sorted.flow.goesin[3]) # 697
which(flow.goesin == sorted.flow.goesin[4]) # 699
# [1] "AD"               "C"                "POP.node"         "cases.node.day"
# "distances"        "no.toilet.access" "no.water.access"
# [8] "time"
all851nodes.id <- 1:851
dist.851mat <- rawnet$distances
#-------------------------------------------------------------------------------
## visualize all the nodes
# if(!requireNamespace("devtools")) install.packages("devtools")
# devtools::install_github("dkahle/ggmap", ref = "tidyup")
library(igraph)
library(ggmap)
register_google('AIzaSyAeKnH7oBIBNhfmok-_WZcaxkgkTgEQG5M')
library(ggplot2)
library(maps)
library(plotrix)
label.vec <- R0
node.name = rep(NA, 851)
node.name[188] = "Src(?)1"
node.name[354] = "Src(?)2"
node.name[182] = "Src(?)3"
node.name[422] = "Src(?)4"
node.name[472] = "Src(?)5"
node.name[c(604,366,519,707,465,451,408,544,274)] <- rep("Obs", 9)
lati.long.851 <- cbind(rawnet$C[all851nodes.id, 1], rawnet$C[all851nodes.id, 2])
location.df <- data.frame(latitude = lati.long.851[, 2],
longitude = lati.long.851[, 1],
Pop.1000s = rawnet$POP.node[all851nodes.id] / 1000,
id = 1:851,
label = label.vec,
name = node.name)
# map <- get_map(location = c(lon = mean(location.df$longitude), lat = mean(location.df$latitude)), zoom = 8)
nodes <- data.frame(id = 1:851,
x = location.df$longitude,
y = location.df$latitude)
### remake humanmob mat
humanmob.new <- matrix(NA, 851, 851)
for (j in 1:851){
curr.row = humanmob.mass[j, ]
curr.mark = sort(curr.row, decreasing = TRUE)[3]
curr.row[curr.row < curr.mark] = 0
humanmob.new[j, ] = curr.row
}
edges.df <- data.frame(from.id = c(), to.id = c(), weight = c())
for (j in 1:851) {
edges.df.tmp <- data.frame(from.id = rep(j, 851),
to.id = 1:851,
weight = humanmob.new[j, ])
edges.df.tmp <- edges.df.tmp[edges.df.tmp$weight != 0, ]
edges.df <- rbind(edges.df, edges.df.tmp)
cat(paste0("j: ", toString(j), "\n"))
}
dim(edges.df) # 2553      3
###
edges <- edges.df
min.weight <- min(edges$weight)
max.weight <- max(edges$weight)
library(gtools)
rescale.wts <- (edges$weight - min.weight) / (max.weight - min.weight)
safe.rescale.wts <- rescale.wts + 10^(-10)
safe.rescale.wts[safe.rescale.wts > 1 - 10^(-10)] <- (1 - 10^(-10))
# logit.wts <- logit(safe.rescale.wts)
edges$weight <- safe.rescale.wts
#### reset edges weights
length(edges$weight) # 2553
mark <- sort(edges$weight, decreasing = TRUE)[255]
edges$weight[edges$weight < mark] <- edges$weight[edges$weight < mark]/10.0
routes <- tbl_graph(nodes = nodes, edges = edges, directed = TRUE)
# print(routes)
gg <- ggraph(routes, layout = "nicely")
library(ggrepel)
# map <- get_map(location = c(lon = mean(location.df$longitude), lat = mean(location.df$latitude)), zoom = 8)
q.all2 <- gg + geom_sf(data = world, fill = "cornsilk") +
geom_node_point() +
geom_edge_link(aes(
width = weight, alpha=weight, color='#d3d3d3'), show.legend=F) +
theme_graph() +
geom_point(data = location.df, aes(x = longitude, y = latitude, size = Pop.1000s, colour = label)) +
geom_label_repel(data = location.df, aes(x = longitude, y = latitude, label=name),hjust=0, vjust=0) +
coord_sf(xlim = c(28.8, 32.5), ylim = c(-31.1, -26.8), expand = FALSE) +
labs(x="") + labs(y="") + ggtitle("") +
theme(legend.position = 'none')
q.all2
ggsave(filename=paste0(dir.rfiles, "ResultsWave1Unif_0510_ccby_1008update.pdf"),
plot=q.all2,
width = 10, height = 10)
edges.df <- data.frame(from.id = c(), to.id = c(), weight = c())
for (j in 1:851) {
edges.df.tmp <- data.frame(from.id = rep(j, 851),
to.id = 1:851,
weight = humanmob.new[j, ])
edges.df.tmp <- edges.df.tmp[edges.df.tmp$weight != 0, ]
edges.df <- rbind(edges.df, edges.df.tmp)
cat(paste0("j: ", toString(j), "\n"))
}
dim(edges.df) # 2553      3
###
edges <- edges.df
min.weight <- min(edges$weight)
max.weight <- max(edges$weight)
library(gtools)
rescale.wts <- (edges$weight - min.weight) / (max.weight - min.weight)
safe.rescale.wts <- rescale.wts + 10^(-10)
safe.rescale.wts[safe.rescale.wts > 1 - 10^(-10)] <- (1 - 10^(-10))
# logit.wts <- logit(safe.rescale.wts)
edges$weight <- safe.rescale.wts
#### reset edges weights
length(edges$weight) # 2553
mark <- sort(edges$weight, decreasing = TRUE)[255]
edges$weight[edges$weight < mark] <- 0 #edges$weight[edges$weight < mark]/10.0
routes <- tbl_graph(nodes = nodes, edges = edges, directed = TRUE)
# print(routes)
gg <- ggraph(routes, layout = "nicely")
library(ggrepel)
# map <- get_map(location = c(lon = mean(location.df$longitude), lat = mean(location.df$latitude)), zoom = 8)
q.all2 <- gg + geom_sf(data = world, fill = "cornsilk") +
geom_node_point() +
geom_edge_link(aes(
width = weight, alpha=weight, color='#d3d3d3'), show.legend=F) +
theme_graph() +
geom_point(data = location.df, aes(x = longitude, y = latitude, size = Pop.1000s, colour = label)) +
geom_label_repel(data = location.df, aes(x = longitude, y = latitude, label=name),hjust=0, vjust=0) +
coord_sf(xlim = c(28.8, 32.5), ylim = c(-31.1, -26.8), expand = FALSE) +
labs(x="") + labs(y="") + ggtitle("") +
theme(legend.position = 'none')
q.all2
ggsave(filename=paste0(dir.rfiles, "ResultsWave1Unif_0510_ccby_1008update.pdf"),
plot=q.all2,
width = 10, height = 10)
library(gtools)
permute(1:6)
permute(1:6)
b <- permute(as.vector(humanmob.mass))
sum(b)
sum(humanmob.mass)
sum(as.vector(humanmob.mass))
# use 0.01 as threshold: 16047 links
sum(df.humanmob$weight > 0.01)
## 1. load packages and data, functions
# visualize the observers
library(mvtnorm)
library(R.matlab)
library(tidygraph)
library(ggraph)
library(gtools)
library(ggplot2)
dir.rfiles <- "/Users/lijun/Documents/source_detect_2020/storage/" # path for .mat data
rawnet <- readMat(paste0(dir.rfiles, 'KZN_dataset.mat'))
R0 <- readMat(paste0(dir.rfiles, "R0.mat"))$R0
R0 <- R0/max(R0) * 5.6
humanmob.mass <- readMat(paste0(dir.rfiles, 'human_mob_in_851.mat'))$fluxes
library(igraph)
max(humanmob.mass) # 0.2487348
quantile(as.vector(humanmob.mass))
# 0%          25%          50%          75%         100%
# 0.0000000000 0.0000242024 0.0001417434 0.0007166013 0.2487347872
df.humanmob <- data.frame(weight=as.vector(humanmob.mass))
ClustCoefDir <- function(graph) {
A <- as.matrix(get.adjacency(graph))
S <- A + t(A)
deg <- degree(graph, mode = c("total"))
num <- diag(S %*% S %*% S)
denom <- diag(A %*% A)
denom <- 2 * (deg * (deg - 1) - 2 * denom)
cl <- mean(num / denom)
return(cl)
}
A.original <- humanmob.mass
G.original <- graph_from_adjacency_matrix(A.original, mode = "directed")
humanmob.clustcoef <- ClustCoefDir(G.original)
humanmob.clustcoef # 0.5675805
graph <- humanmob.mass
A <- as.matrix(get.adjacency(graph))
S <- A + t(A)
deg <- degree(graph, mode = c("total"))
graph <- G.original
A <- as.matrix(get.adjacency(graph))
S <- A + t(A)
deg <- degree(graph, mode = c("total"))
deg
num <- diag(S %*% S %*% S)
denom <- diag(A %*% A)
denom
denom <- 2 * (deg * (deg - 1) - 2 * denom)
denom
num
A.original <- humanmob.mass
G.original <- graph_from_adjacency_matrix(A.original, mode = "directed")
G.original
sum(sum(humanmob.mass))
install.packages("DirectedClustering")
library(DirectedClustering)
ClustBCG(humanmob.mass, type = "directed", isolates = "zero")
A.original <- humanmob.mass
G.original <- graph_from_adjacency_matrix(A.original, mode = "directed", weighted = TRUE)
humanmob.clustcoef <- ClustCoefDir(G.original)
humanmob.clustcoef
graph <- G.original
A <- as.matrix(get.adjacency(graph))
S <- A + t(A)
deg <- degree(graph, mode = c("total"))
num <- diag(S %*% S %*% S)
denom <- diag(A %*% A)
denom <- 2 * (deg * (deg - 1) - 2 * denom)
num
denom
ClustCoefDir <- function(graph) {
A <- as.matrix(get.adjacency(graph))
S <- A + t(A)
deg <- degree(graph, mode = c("out"))
num <- diag(S %*% S %*% S)
denom <- diag(A %*% A)
denom <- 2 * (deg * (deg - 1) - 2 * denom)
cl <- mean(num / denom)
return(cl)
}
A.original <- humanmob.mass
G.original <- graph_from_adjacency_matrix(A.original, mode = "directed", weighted = TRUE)
humanmob.clustcoef <- ClustCoefDir(G.original)
humanmob.clustcoef # 0.5675805
ClustCoefDir <- function(graph, typemode) {
A <- as.matrix(get.adjacency(graph))
S <- A + t(A)
deg <- degree(graph, mode = typemode)
num <- diag(S %*% S %*% S)
denom <- diag(A %*% A)
denom <- 2 * (deg * (deg - 1) - 2 * denom)
cl <- mean(num / denom)
return(cl)
}
ClustCoefDir <- function(graph, typemode) {
A <- as.matrix(get.adjacency(graph))
S <- A + t(A)
deg <- degree(graph, mode = typemode)
num <- diag(S %*% S %*% S)
denom <- diag(A %*% A)
denom <- 2 * (deg * (deg - 1) - 2 * denom)
cl <- mean(num / denom)
return(cl)
}
humanmob.clustcoef <- ClustCoefDir(G.original, "all")
humanmob.clustcoef # 4.009445
humanmob.clustcoef <- ClustCoefDir(G.original, "out")
humanmob.clustcoef # 4.009445
humanmob.clustcoef <- ClustCoefDir(G.original, "in")
humanmob.clustcoef # 4.009445
average.path.length(G.cut05) # 4.027839
average.path.length(G.original) # 4.027839
mean_distance(G.original, directed = TRUE, unconnected = TRUE)
library(devtools)
library(roxygen2)
dir.rfiles <- "/Users/lijun/Documents/GitHub/NetOrigin3"
setwd(dir.rfiles)
document()
